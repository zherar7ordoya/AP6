

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" >

<!-- Mirrored from mvcsharp.org/Designing_Winforms_views_engine/Default.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 30 Oct 2008 03:47:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head><title>
	Designing a Windows Forms views engine
</title><link href="../Styles.css" rel="stylesheet" type="text/css" /></head>
<body>
    <form name="aspnetForm" method="post" action="http://mvcsharp.org/Designing_Winforms_views_engine/Default.aspx" id="aspnetForm">
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwULLTEwMDUyNjYzMjgPZBYCZg9kFgICAw9kFgICCQ88KwAJAgAPFgQeDU5ldmVyRXhwYW5kZWRkHgtfIURhdGFCb3VuZGdkCBQrAAUFDzA6MCwwOjEsMDoyLDA6MxQrAAIWDB4EVGV4dAUNRG9jdW1lbnRhdGlvbh4FVmFsdWUFDURvY3VtZW50YXRpb24eC05hdmlnYXRlVXJsBRMvRG9jdW1lbnRhdGlvbi5hc3B4HghEYXRhUGF0aAUTL2RvY3VtZW50YXRpb24uYXNweB4JRGF0YUJvdW5kZx4IRXhwYW5kZWRnFCsABQUPMDowLDA6MSwwOjIsMDozFCsAAhYKHwIFCE92ZXJ2aWV3HwMFCE92ZXJ2aWV3HwQFFi9PdmVydmlldy9EZWZhdWx0LmFzcHgfBQUWL292ZXJ2aWV3L2RlZmF1bHQuYXNweB8GZ2QUKwACFgofAgUIRXhhbXBsZXMfAwUIRXhhbXBsZXMfBAUOL0V4YW1wbGVzLmFzcHgfBQUOL2V4YW1wbGVzLmFzcHgfBmcUKwAHBRcwOjAsMDoxLDA6MiwwOjMsMDo0LDA6NRQrAAIWCh8CBRwxLiBHZXR0aW5nIHN0YXJ0ZWQgd2l0aCBNVkMjHwMFHDEuIEdldHRpbmcgc3RhcnRlZCB3aXRoIE1WQyMfBAUrL0dldHRpbmdfc3RhcnRlZF93aXRoX01WQ1NoYXJwL0RlZmF1bHQuYXNweB8FBSsvZ2V0dGluZ19zdGFydGVkX3dpdGhfbXZjc2hhcnAvZGVmYXVsdC5hc3B4HwZnZBQrAAIWCh8CBRQyLiBUYXNrcyBpbnRlcmFjdGlvbh8DBRQyLiBUYXNrcyBpbnRlcmFjdGlvbh8EBR8vVGFza3NfSW50ZXJhY3Rpb24vRGVmYXVsdC5hc3B4HwUFHy90YXNrc19pbnRlcmFjdGlvbi9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFHjMuIFVzaW5nIFdpbmZvcm1zIHZpZXdzIGVuZ2luZR8DBR4zLiBVc2luZyBXaW5mb3JtcyB2aWV3cyBlbmdpbmUfBAUpL1VzaW5nX1dpbmZvcm1zX3ZpZXdzX2VuZ2luZS9EZWZhdWx0LmFzcHgfBQUpL3VzaW5nX3dpbmZvcm1zX3ZpZXdzX2VuZ2luZS9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFKDQuIFJld29ya2luZyBBU1AuTkVUIE1WQyBTdG9yZSB3aXRoIE1WQyMfAwUoNC4gUmV3b3JraW5nIEFTUC5ORVQgTVZDIFN0b3JlIHdpdGggTVZDIx8EBSgvUmV3b3JraW5nX0FTUE5FVF9NVkNfU3RvcmUvRGVmYXVsdC5hc3B4HwUFKC9yZXdvcmtpbmdfYXNwbmV0X212Y19zdG9yZS9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFGTUuIEFkdmFuY2VkIEN1c3RvbWl6YXRpb24fAwUZNS4gQWR2YW5jZWQgQ3VzdG9taXphdGlvbh8EBSQvQWR2YW5jZWRfQ3VzdG9taXphdGlvbi9EZWZhdWx0LmFzcHgfBQUkL2FkdmFuY2VkX2N1c3RvbWl6YXRpb24vZGVmYXVsdC5hc3B4HwZnZBQrAAIWCh8CBRo2LiBTaWx2ZXJsaWdodCBhbmQgLk5FVCBDRh8DBRo2LiBTaWx2ZXJsaWdodCBhbmQgLk5FVCBDRh8EBREvU2lsdmVybGlnaHQuYXNweB8FBREvc2lsdmVybGlnaHQuYXNweB8GZ2QUKwACFgofAgUIQVBJIERvY3MfAwUIQVBJIERvY3MfBAUUL0FQSV9Eb2NzL0luZGV4LmFzcHgfBQUUL2FwaV9kb2NzL2luZGV4LmFzcHgfBmdkFCsAAhYMHwIFC0RldmVsb3BtZW50HwMFC0RldmVsb3BtZW50HwQFES9EZXZlbG9wbWVudC5hc3B4HwUFES9kZXZlbG9wbWVudC5hc3B4HwZnHwdnFCsABQUPMDowLDA6MSwwOjIsMDozFCsAAhYKHwIFGDEuIEJhc2ljcyBvZiBNVkMgYW5kIE1WUB8DBRgxLiBCYXNpY3Mgb2YgTVZDIGFuZCBNVlAfBAUjL0Jhc2ljc19vZl9NVkNfYW5kX01WUC9EZWZhdWx0LmFzcHgfBQUjL2Jhc2ljc19vZl9tdmNfYW5kX212cC9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFJjIuIEltcGxlbWVudGluZyBjb3JlIE1WUCBmdW5jdGlvbmFsaXR5HwMFJjIuIEltcGxlbWVudGluZyBjb3JlIE1WUCBmdW5jdGlvbmFsaXR5HwQFMS9JbXBsZW1lbnRpbmdfY29yZV9NVlBfZnVuY3Rpb25hbGl0eS9EZWZhdWx0LmFzcHgfBQUxL2ltcGxlbWVudGluZ19jb3JlX212cF9mdW5jdGlvbmFsaXR5L2RlZmF1bHQuYXNweB8GZ2QUKwACFg4fAgUiMy4gRGVzaWduaW5nIFdpbmZvcm1zIHZpZXdzIGVuZ2luZR8DBSIzLiBEZXNpZ25pbmcgV2luZm9ybXMgdmlld3MgZW5naW5lHwQFLS9EZXNpZ25pbmdfV2luZm9ybXNfdmlld3NfZW5naW5lL0RlZmF1bHQuYXNweB8FBS0vZGVzaWduaW5nX3dpbmZvcm1zX3ZpZXdzX2VuZ2luZS9kZWZhdWx0LmFzcHgfBmceCFNlbGVjdGVkZx8HZ2QUKwACFgofAgUeNC4gU3Ryb25nbHkgdHlwZWQgYXNzb2NpYXRpb25zHwMFHjQuIFN0cm9uZ2x5IHR5cGVkIGFzc29jaWF0aW9ucx8EBSkvU3Ryb25nbHktdHlwZWRfYXNzb2NpYXRpb25zL0RlZmF1bHQuYXNweB8FBSkvc3Ryb25nbHktdHlwZWRfYXNzb2NpYXRpb25zL2RlZmF1bHQuYXNweB8GZ2QUKwACFgofAgUHQ2hhbmdlcx8DBQdDaGFuZ2VzHwQFDS9DaGFuZ2VzLmFzcHgfBQUNL2NoYW5nZXMuYXNweB8GZ2QUKwACFgofAgUIRmVlZGJhY2sfAwUIRmVlZGJhY2sfBAUOL0ZlZWRiYWNrLmFzcHgfBQUOL2ZlZWRiYWNrLmFzcHgfBmdkFCsAAhYKHwIFCERvd25sb2FkHwMFCERvd25sb2FkHwQFDi9Eb3dubG9hZC5hc3B4HwUFDi9kb3dubG9hZC5hc3B4HwZnZGQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFgEFCmN0bDAwJE1lbnUQdPHbn9KokQ4/8xronnARHlG2fA==" />

        <div id="pageWrapper">
            
            <div>
                <img id="ctl00_logo" src="../Images/logo.PNG" border="0" />
                <div id="breadcrumbs">
                    <div><img id="ctl00_spacer" src="../Images/spacer.bmp" height="1" width="875" border="0" /></div>
                    <span id="ctl00_SiteMapPath"><a href="#ctl00_SiteMapPath_SkipLink"><img alt="Skip Navigation Links" height="0" width="0" src="../WebResourcee862.gif?d=-tf2UOPilGOzHQ2P_iOPlg2&amp;t=633440833918844552" border="0" /></a><span><a href="../Default.html">Home</a></span><span>&#160;&gt;&#160;</span><span><a href="../Documentation.html">Documentation</a></span><span>&#160;&gt;&#160;</span><span><a href="../Development.html">Development</a></span><span>&#160;&gt;&#160;</span><span>3. Designing Winforms views engine</span><a id="ctl00_SiteMapPath_SkipLink"></a></span>
                </div>
            </div>
            <div id="menuAndContent">
                <div id="menu">
                    <a href="#ctl00_Menu_SkipLink"><img alt="Skip Navigation Links." src="../WebResourcee862.gif?d=-tf2UOPilGOzHQ2P_iOPlg2&amp;t=633440833918844552" width="0" height="0" border="0" /></a><table id="ctl00_Menu" cellpadding="0" cellspacing="0" border="0" width="238"><tr><td>
	<table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Documentation.html" id="ctl00_Menun0">Documentation</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Overview/Default.html" id="ctl00_Menun1">Overview</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Examples.html" id="ctl00_Menun2">Examples</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="http://mvcsharp.org/API_Docs/Index.aspx" id="ctl00_Menun9">API Docs</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Development.html" id="ctl00_Menun10">Development</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Basics_of_MVC_and_MVP/Default.html" id="ctl00_Menun11">1. Basics of MVC and MVP</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Implementing_core_MVP_functionality/Default.html" id="ctl00_Menun12">2. Implementing core MVP functionality</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItemSelected menuItem"><a class="menuItemSelected menuItem" href="Default.html" id="ctl00_Menun13">3. Designing Winforms views engine</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Strongly-typed_associations/Default.html" id="ctl00_Menun14">4. Strongly typed associations</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Changes.html" id="ctl00_Menun15">Changes</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Feedback.html" id="ctl00_Menun16">Feedback</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Download.html" id="ctl00_Menun17">Download</a></td>
		</tr>
	</table>
</td></tr></table><a id="ctl00_Menu_SkipLink"></a>
                </div> 
                <div id="content">  
                    
<h1>
    Part 3.
    Designing a Windows Forms views engine</h1>
    <p>
        <a href="#Introduction">Introduction</a><br />
        <a href="#Requirements">Requirements</a><br />
        &nbsp; &nbsp;
        <a href="#User control views">User control views</a><br />
        &nbsp; &nbsp;
        <a href="#MDI form views">MDI form views</a><br />
        &nbsp; &nbsp;
        <a href="#Modal form views">Modal form views</a><br />
        &nbsp; &nbsp;
        <a href="#Different views with same type">Different views with same type</a><br />
        &nbsp; &nbsp;
        <a href="#Notifications to views">Notifications to views</a><br />
        &nbsp; &nbsp;
        <a href="#Base views implementations">Base views implementations</a><br />
        <a href="#Implementation">Implementation</a><br />
        &nbsp; &nbsp;
        <a href="#General classes">General classes</a><br />
        &nbsp; &nbsp;
        <a href="#WinformsViewsManager class">WinformsViewsManager class</a><br />
        <a href="#Summary">Summary</a><br /></p>    
    <a id="Introduction"></a><h2>
        Introduction</h2>
    <p>
        In the previous articles (parts <a href="../Basics_of_MVC_and_MVP/Default.html">1</a>-<a
            href="../Implementing_core_MVP_functionality/Default.html">2</a>) we have introduced a views manager concept
        for isolating the presentation mechanism of the MVP framework. This article describes
        the development of the real-life Windows Forms views manager and its attendant classes
        for our MVP framework.</p>
    <p>
        The only responsibility of a views manager is switching between views. This might
        seem easy at first sight, however it becomes more tricky as we delve deeper into
        the presentation specifics and take into account pecularities of the views mechanism.
        For example in the previous part we have already created a simple Windows Forms
        views manager, however it is not able to treat user controls as views, neither it
        can handle dialogs or MDI forms.</p>
    <p>
        That is why for creating a fully functional views manager we need to thoroughly
        analyze the corresponding presentation mechanism and construct requirements to that
        views manager. These requirements will typically include the description of possible
        view types, thier interrelation and so on. Thus our first step is building requirements
        to the constructed views manager. We will assume that the basic requirements of
        working with simple forms are already implemented (see the end of the previous article
        where we constructed a simple forms views manager) and will proceed to the more
        advanced demands.</p>
    <a id="Requirements"></a><h2>
        Requirements</h2>
    <a id="User control views"></a><h3>
        User control views</h3>
    <p>
        The starting point for building the first requirement will be the fact that a user
        might want to have more than one interaction point on his screen at a moment. Although
        separate, these views may be logically coupled, which discourages us from placing
        them onto different forms. A more plausible (and popular in modern GUIs) solution
        is putting views into different parts of a single form. For instance an orders
        view and an order lines view can be displayed as parts (e.g. upper and lower halfs)
        of a common window.</p>
    <p>
        In .NET Windows Forms technology such views are implemented as user controls. They
        are designed separately, but finally are placed together and arranged on a single
        form. Thus in general our requirement sounds like this: UserControl class descedants
        may be used as views.</p>
    <p>
        To express this requirement in a more precise form let us decide how a developer
        would mark a particular user control to be used as a view. Here two alternatives
        are possible: 1) Let the framework create an instance of the user control, 2) Create
        the user control istance manually and place it on some view. If a developer chooses
        2 (to create an instance himself) then how will the framework distinguish the user control-view from an ordinary user
        control? The answer is quite obvious here: a user control class should implement
        the IView interface to make the MVP framework treat it as a view. So here is how
        the first use case looks:</p>
    <pre lang="cs"><span style="text-decoration: underline">User control views</span>
    User: Create a UserControl sublass which implements the IView interface.
          Place its instance on some view. Assign a ViewName property to it.
    System: Find this user control and initialize it (tie to the controller,
            register in the system and so forth)
</pre>
    <p>
        Here we have included the view name assignment to the user's actions. That is because
        a view initialization requires the knowledge of that view's name.</p>
    <p>
        However the view registration and initialization are not the only necessary activities.
        We should also consider how a user control view should be activated. Unlike forms
        user controls cannot be activated, instead they have a Focus() method which moves
        in the input focus. However focusing a user control is of little use if the parent
        form is inactive, therefore we should also assure the parent form activation:</p>
    <pre lang="cs"><span style="text-decoration: underline">Activating a user control view</span>
    User: Trigger a user control view activation (via Navigator.Naviagate(.).
    System: Activate the parent form and Call the Focus() method on the
            user control view.</pre>
    <p>
        A manual user control view activation is possible too when a user clicks somewhere
        inside that user control. As a response the system should perform navigation to
        this view:</p>
    <pre lang="cs"><span style="text-decoration: underline">Manual user control view activation</span>
    End user: Click on a user control view (or somehow else move the focus
              inside it).
    System: Perform the navigation to this view.</pre>
    <a id="MDI form views"></a><h3>
        MDI form views</h3>
    <p>
        Another kind of view we might want to use is the MDI form. Although slightly out
        of fashion nowdays, MDI forms may prove useful in various applications. That is
        why the next requirement will concern the usage of MDI forms as views.</p>
    <p>
        Applying MDI forms in .NET is simple: the only thing needed is to specify the parent
        form by setting its isMdiContainer property to true and to set MdiParent property
        for all child forms. We could link child forms to the parent form instances by ourselves,
        however it is not as easy since the MVP framework and particulary the views manager
        itself creates forms and holds their instances. The better approach is to somehow
        tell the framework which views should act as MDI parents, and which ones should
        be their children. A good way of doing so is applying a .NET attribute with necessary
        parameters to the view type, like this: [WinformsView("ChildView", typeof(MainTask),
        MdiParent = "ParentView")]. So here is the next use case:</p>
    <pre lang="cs"><span style="text-decoration: underline">MDI form views</span>
    User: Equip the form type with a WinformsView attribute with MdiParent
          or isMdiParent named parameters. Then at some point navigate to
          the corresponding view.
    System: Initialize the view as an MDI parent or child as specified.</pre>
    <p>
        With respect to the view activation mechanism MDI forms behave the same way as simple
        forms do. So let us turn to the next requirement.</p>
    <a id="Modal form views"></a><h3>
        Modal form views</h3>
    <p>
        Modal forms (dialogs) are very useful if we want a user to interact with only one
        form until he closes it. In .NET a form modality depends on the way how it is shown.
        Form.Show() displays form in an ordinary (not modal) state, while Form.ShowModal()
        displays it as modal. Anyway it is a job of the views manager to show forms, and
        we should somehow indicate it which forms to display as modal. As in previous requirement
        we may use a .NET attribute with a named parameter ShowModal: [WinformsView("ChildView",
        typeof(MainTask), ShowModal = true)]. This is the use case:</p>
    <pre lang="cs"><span style="text-decoration: underline">Modal form views</span>
    User: Equip the form type with a WinformsView attribute with a ShowModal
          named parameter. Then navigate to the corresponding view.
    System: Show the form as modal by calling Form.ShowDialog().</pre>
    <a id="Different views with same type"></a><h3>
        Different views with same type</h3>
    <p>
        Applying the [View("ViewName", ...)] or [WinformsView("ViewName", ...)] attribute
        to a view type we specify the concrete view type for the interaction point with
        "ViewName" view name. But what if another view should be of the same type? The answer
        is straightforward: allow users to specify several [(Winforms)View] attributes with
        different view names for a single view type:</p>
    <pre lang="cs"><span style="text-decoration: underline">Different views with same type</span>
    User: Equip a view type with several (Winforms)View attributes.
    System: Treat this as descriptions of different views with the
            same view type.</pre>
    <a id="Notifications to views"></a><h3>
        Notifications to views</h3>
    <p>
        It may be important for a view to react in a particular way when it gets (de)activated.
        For example a view may disable some controls on it when it loses focus. A view may
        also need to perform some initalization steps when it is activated for a first time.
        For this we need notifications to be sent to views whenever they are (de)activated
        or initialized (activated for a first time).</p>
    <p>
        For handling a view (de)activation we might watch the change of the Task.CurrentViewName
        property. The view initialization can be done in the IView.Controller setter method.
        Much more straightforward, however, is to have explicit Activate(bool activate)
        and Initialize() operations, invoked by the views manager. These operations may
        be placed in a separate INotifiedView interface.</p>
    <pre lang="cs"><span style="text-decoration: underline">Notifications to views</span>
    User: Invoke navigation to/from a view that implements INotifiedView
          interface.
    System: Call Activate(true/false) on that view. Call Initialize() on
            it if activated for a first time.</pre>
    <a id="Base views implementations"></a><h3>
        Base views implementations</h3>
    <p>
        Each form or user control we want to be a view should implement the IView interface.
        It would be convenient if the framework provides developers with base form and user
        control classes which already implement IView and even INotifiedView interfaces.
        For example these could be WinFormView and WinUserControlView classes.</p>
    <p>
        Now we have finished with building requirements and will proceed to the implementation
        phase.</p>
    <a id="Implementation"></a><h2>
        Implementation</h2>
    <a id="General classes"></a><h3>
        General classes</h3>
    <p>
        First we will implement the WinformsView attribute with optional parameters as defined
        in the "MDI form views" and "Modal form views" use cases:</p>
    <pre lang="cs"><span style="color: #000000;">[AttributeUsage(AttributeTargets.Class, AllowMultiple </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">true</span><span style="color: #000000;">)]
</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewAttribute : ViewAttribute
{
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> WinformsViewAttribute(Type taskType, </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
        : </span><span style="color: #0000FF;">base</span><span style="color: #000000;">(taskType, viewName) { }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> WinformsViewAttribute() { }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">bool</span><span style="color: #000000;"> ShowModal
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">bool</span><span style="color: #000000;"> IsMdiParent
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> MdiParent
    ...
}</span></pre>
    <p>
        In the previous article we have introduced the DefaultViewInfosProvider class for
        processing [View] attributes. For each met [View] attribute it created a ViewInfo
        instance. Similarly we should treat [WinformsViewAttribute] attributes, except for
        that WinformsViewInfo objects should be created instead of simple ViewInfo objects.</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewInfosProvider : DefaultViewInfosProvider
{
    </span><span style="color: #0000FF;">protected</span><span style="color: #000000;"> </span><span style="color: #0000FF;">override</span><span style="color: #000000;"> ViewInfo newViewInfo(Type viewType, ViewAttribute viewAttr)
    {
        WinformsViewInfo viewInfo </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> WinformsViewInfo(viewType);
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">!</span><span style="color: #000000;">(viewAttr </span><span style="color: #0000FF;">is</span><span style="color: #000000;"> WinformsViewAttribute)) </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> viewInfo;

        viewInfo.IsMdiParent </span><span style="color: #000000;">=</span><span style="color: #000000;"> (viewAttr </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> WinformsViewAttribute).IsMdiParent;
        viewInfo.MdiParent </span><span style="color: #000000;">=</span><span style="color: #000000;"> (viewAttr </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> WinformsViewAttribute).MdiParent;
        viewInfo.ShowModal </span><span style="color: #000000;">=</span><span style="color: #000000;"> (viewAttr </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> WinformsViewAttribute).ShowModal;
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> viewInfo;
    }
}

</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewInfo : ViewInfo
{
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> WinformsViewInfo(Type viewType) : </span><span style="color: #0000FF;">base</span><span style="color: #000000;">(viewType)
    { }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">bool</span><span style="color: #000000;"> ShowModal
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">bool</span><span style="color: #000000;"> IsMdiParent
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> MdiParent
    ...
}</span></pre>
    <p>
        Notice that "AllowMultiple = true" is specified for the WinformsViewAttribute (as
        well as for the ViewAttribute). By doing so we meet the "Different views with same
        type" requirement.</p>
    <p>
        One more simple requirement we will implement before proceeding to the more complicated
        ones is the "Base views implementations" requirement. For that we will create Form
        and UserControl descedants and make them implement IView and IWinformsView interfaces
        in a simpliest way: with the use of virtual properties with backing fields and empty
        virtual methods:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinFormView : Form, IView, IWinformsView
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> IView and IWinformsView implementations with virtual
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> methods and virtual properties with backing fields</span><span style="color: #008000;">
</span><span style="color: #000000;">    ...
}

</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinUserControlView : UserControl, IView, IWinformsView
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> IView and IWinformsView implementations with virtual
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> methods and virtual properties with backing fields</span><span style="color: #008000;">
</span><span style="color: #000000;">    ...
}
\</span></pre>
    <a id="WinformsViewsManager class"></a><h3>
        WinformsViewsManager class</h3>
    <p>
        WinformsViewsManager class will inherit from ViewsManagerBase - a simpliest IViewsManager
        implementation:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...    
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">override</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> ActivateView(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        IView view </span><span style="color: #000000;">=</span><span style="color: #000000;"> FindOrCreateView(viewName);
        NotifyViewsOnActivation(view);
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (view </span><span style="color: #0000FF;">is</span><span style="color: #000000;"> Form)
            ActivateFormView(view);
        </span><span style="color: #0000FF;">else</span><span style="color: #000000;"> </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (view </span><span style="color: #0000FF;">is</span><span style="color: #000000;"> UserControl)
            ActivateUserControlView(view);
    }</span></pre>
    <p>
        In the ActivateView method above we do the following: get already created view from
        an internal hash or create a new one and activate this view in a manner depending
        on the view kind. Between these two steps we notify views about their (de)activation
        in the NotifyViewsOnActivation(...) method - this is required by the "Notifications
        to views" use case:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> NotifyViewsOnActivation(IView activatedView)
    {
        IWinformsView prevActiveWFView </span><span style="color: #000000;">=</span><span style="color: #000000;"> prevActiveView </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IWinformsView;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (prevActiveWFView </span><span style="color: #000000;">!=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">) prevActiveWFView.Activate(</span><span style="color: #0000FF;">false</span><span style="color: #000000;">);
        IWinformsView winformsView </span><span style="color: #000000;">=</span><span style="color: #000000;"> activatedView </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IWinformsView;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (winformsView </span><span style="color: #000000;">!=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">) winformsView.Activate(</span><span style="color: #0000FF;">true</span><span style="color: #000000;">);
        prevActiveView </span><span style="color: #000000;">=</span><span style="color: #000000;"> activatedView;
    }</span></pre>
    <p>
        FindOrCreateView(...) method instantiates views if they do not exist yet. Type information
        is taken from the appropriate WinformsViewInfo object. Then, depending on the view
        type (form or user control), the corresponding view initialization method is invoked:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> IView FindOrCreateView(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        IView result </span><span style="color: #000000;">=</span><span style="color: #000000;"> views[viewName] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (result </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">)
        {
            WinformsViewInfo viewInf </span><span style="color: #000000;">=</span><span style="color: #000000;"> ViewInfos[viewName] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> WinformsViewInfo;
            result </span><span style="color: #000000;">=</span><span style="color: #000000;"> CreateHelper.Create(ViewInfos[viewName].ViewType) </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView;
            result.ViewName </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewName;
            </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (result </span><span style="color: #0000FF;">is</span><span style="color: #000000;"> UserControl)
                InitializeUserControlView(result </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> UserControl);
            </span><span style="color: #0000FF;">else</span><span style="color: #000000;"> </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (result </span><span style="color: #0000FF;">is</span><span style="color: #000000;"> Form)
                InitializeFormView(result </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> Form, viewInf);
        }
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> result;
    }</span></pre>
    <p>
        Below are the methods for user control and form initialization:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">protected</span><span style="color: #000000;"> </span><span style="color: #0000FF;">virtual</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> InitializeUserControlView(UserControl userControlView)
    {
        InitializeView(userControlView </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView);
        userControlView.Enter </span><span style="color: #000000;">+=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> EventHandler(view_ActivatedManually);
</span><span style="color: #000000;">        NotifyInitialize(userControlView </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView);
        InitializeChildViews(userControlView);
    }
</span>
<span style="color: #000000;">    </span><span style="color: #0000FF;">protected</span><span style="color: #000000;"> </span><span style="color: #0000FF;">virtual</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> InitializeFormView(Form form, WinformsViewInfo viewInf)
    {
        InitializeView(form </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView);
        form.Activated </span><span style="color: #000000;">+=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> EventHandler(view_ActivatedManually);
</span><span style="color: #000000;">        form.IsMdiContainer </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewInf.IsMdiParent;
        </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> mdiParent </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewInf.MdiParent;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (mdiParent </span><span style="color: #000000;">!=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">)
            form.MdiParent </span><span style="color: #000000;">=</span><span style="color: #000000;"> views[mdiParent] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> Form;
        NotifyInitialize(form </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView);
        InitializeChildViews(form);
    }</span></pre>
    <p>
        Both these methods use the InitializeView(...) and NotifyInitialize(...) methods
        which contain common initialization steps regardless of the
        view type. InitializeView(...)
        binds together a view with its controller. NotifyInitialize(...) sends an "Initialize"
        message to the view accordingly to the "Notifications to views" requirement:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> InitializeView(IView view)
    {
        views[view.ViewName] </span><span style="color: #000000;">=</span><span style="color: #000000;"> view;
        view.Controller </span><span style="color: #000000;">=</span><span style="color: #000000;"> Navigator.GetController(view.ViewName);
        view.Controller.View </span><span style="color: #000000;">=</span><span style="color: #000000;"> view;
</span><span style="color: #000000;">    }
</span>
<span style="color: #000000;">    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> NotifyInitialize(IView view)
    {
        INotifiedView winformsView </span><span style="color: #000000;">=</span><span style="color: #000000;"> view </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> INotifiedView;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (winformsView </span><span style="color: #000000;">!=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">)
            winformsView.Initialize();
    }</span></pre>
    <p>
        Note that the InitializeFormView(...) method contains code specific to views
        represented as forms: if needed, it makes a form MDI child or parent, thus
        satisfying the "MDI form views" requirement.</p>
    <p>
        InitializeChildViews(...) - is a method that searches for user control views inside
        a form or another user control view. The search is done recursively, for found user
        control views the user control-specific InitializeUserControlView(...) method is
        called. By doing so we implement the "User control views" use case:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">protected</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> InitializeChildViews(Control container)
    {
        </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (Control c </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> container.Controls)
        {
            IView childView </span><span style="color: #000000;">=</span><span style="color: #000000;"> c </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView;
            </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> ((childView </span><span style="color: #000000;">!=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">) </span><span style="color: #000000;">&amp;&amp;</span><span style="color: #000000;"> (</span><span style="color: #000000;">!</span><span style="color: #000000;">IsInitialized(childView)))
                InitializeUserControlView(childView </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> UserControl);
            </span><span style="color: #0000FF;">else</span><span style="color: #000000;">
                InitializeChildViews(c);
        }
    }</span></pre>
    <p>
        By handling the Enter event of user controls we meet the "Manual user control view
        activation" requirement:</p>
    <pre lang="cs"><span style="color: #000000;">    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> view_ActivatedManually(</span><span style="color: #0000FF;">object</span><span style="color: #000000;"> sender, EventArgs e)
    {
        Navigator.TryNavigateToView((sender </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView).ViewName);
    }</span></pre>
    <p>
        The last two methods left are the view activation methods ActivateFormView and ActivateUserControlView.
        The former shows and makes active a form view, taking into account that it could
        be configured as modal (and thus meeting the "Modal form views" requirement):</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> ActivateFormView(IView view)
    {
        Form form </span><span style="color: #000000;">=</span><span style="color: #000000;"> view </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> Form;
        WinformsViewInfo viewInf </span><span style="color: #000000;">=</span><span style="color: #000000;"> ViewInfos[view.ViewName] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> WinformsViewInfo;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (viewInf.ShowModal)
        {
            </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">!</span><span style="color: #000000;">form.Visible) form.ShowDialog();
        }
        </span><span style="color: #0000FF;">else</span><span style="color: #000000;">
        {
            form.Show();
            form.Activate();
        }
    }</span></pre>
    <p>
        ActivateUserControlView(...) method not only focuses the user control but it firstly
        activates the parent of this control, thus implementing the "Activating a user
        control view" use case:</p>
    <pre lang="cs"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> WinformsViewsManager : ViewsManagerBase
    ...    
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> ActivateUserControlView(IView view)
    {
        UserControl uc </span><span style="color: #000000;">=</span><span style="color: #000000;"> view </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> UserControl;
        uc.Focus();
        uc.FindForm().Show();
        uc.FindForm().Activate();
    }</span></pre>
    <a id="Summary"></a><h2>
        Summary</h2>
    <p>
        Throughout this article we have been building a comprehensive Windows Forms views
        engine for the Model-View-Presenter framework. We have started with a list of requirements
        for the future views engine and then implemented these requirements in the WinformsViewsManager
        class and other satellite classes. As a result these classes comprise a fully-functional views engine
        suitable for various MVP applications with Windows Forms-based UI. However it is
        not restricted to further extend this views engine tailoring it for specific needs.</p>

                </div>
            </div>
        </div>
        <div style="text-align:center; font-size:11px;">Copyright Â© www.MVCSharp.org</div>
    </form>
</body>

<!-- Mirrored from mvcsharp.org/Designing_Winforms_views_engine/Default.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 30 Oct 2008 03:47:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>
