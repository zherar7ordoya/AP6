

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" >

<!-- Mirrored from mvcsharp.org/Implementing_core_MVP_functionality/Default.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 30 Oct 2008 03:47:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head><title>
	Implementing core MVP functionality
</title><link href="../Styles.css" rel="stylesheet" type="text/css" /></head>
<body>
    <form name="aspnetForm" method="post" action="http://mvcsharp.org/Implementing_core_MVP_functionality/Default.aspx" id="aspnetForm">
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwULLTEwMDUyNjYzMjgPZBYCZg9kFgICAw9kFgICCQ88KwAJAgAPFgQeDU5ldmVyRXhwYW5kZWRkHgtfIURhdGFCb3VuZGdkCBQrAAUFDzA6MCwwOjEsMDoyLDA6MxQrAAIWDB4EVGV4dAUNRG9jdW1lbnRhdGlvbh4FVmFsdWUFDURvY3VtZW50YXRpb24eC05hdmlnYXRlVXJsBRMvRG9jdW1lbnRhdGlvbi5hc3B4HghEYXRhUGF0aAUTL2RvY3VtZW50YXRpb24uYXNweB4JRGF0YUJvdW5kZx4IRXhwYW5kZWRnFCsABQUPMDowLDA6MSwwOjIsMDozFCsAAhYKHwIFCE92ZXJ2aWV3HwMFCE92ZXJ2aWV3HwQFFi9PdmVydmlldy9EZWZhdWx0LmFzcHgfBQUWL292ZXJ2aWV3L2RlZmF1bHQuYXNweB8GZ2QUKwACFgofAgUIRXhhbXBsZXMfAwUIRXhhbXBsZXMfBAUOL0V4YW1wbGVzLmFzcHgfBQUOL2V4YW1wbGVzLmFzcHgfBmcUKwAHBRcwOjAsMDoxLDA6MiwwOjMsMDo0LDA6NRQrAAIWCh8CBRwxLiBHZXR0aW5nIHN0YXJ0ZWQgd2l0aCBNVkMjHwMFHDEuIEdldHRpbmcgc3RhcnRlZCB3aXRoIE1WQyMfBAUrL0dldHRpbmdfc3RhcnRlZF93aXRoX01WQ1NoYXJwL0RlZmF1bHQuYXNweB8FBSsvZ2V0dGluZ19zdGFydGVkX3dpdGhfbXZjc2hhcnAvZGVmYXVsdC5hc3B4HwZnZBQrAAIWCh8CBRQyLiBUYXNrcyBpbnRlcmFjdGlvbh8DBRQyLiBUYXNrcyBpbnRlcmFjdGlvbh8EBR8vVGFza3NfSW50ZXJhY3Rpb24vRGVmYXVsdC5hc3B4HwUFHy90YXNrc19pbnRlcmFjdGlvbi9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFHjMuIFVzaW5nIFdpbmZvcm1zIHZpZXdzIGVuZ2luZR8DBR4zLiBVc2luZyBXaW5mb3JtcyB2aWV3cyBlbmdpbmUfBAUpL1VzaW5nX1dpbmZvcm1zX3ZpZXdzX2VuZ2luZS9EZWZhdWx0LmFzcHgfBQUpL3VzaW5nX3dpbmZvcm1zX3ZpZXdzX2VuZ2luZS9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFKDQuIFJld29ya2luZyBBU1AuTkVUIE1WQyBTdG9yZSB3aXRoIE1WQyMfAwUoNC4gUmV3b3JraW5nIEFTUC5ORVQgTVZDIFN0b3JlIHdpdGggTVZDIx8EBSgvUmV3b3JraW5nX0FTUE5FVF9NVkNfU3RvcmUvRGVmYXVsdC5hc3B4HwUFKC9yZXdvcmtpbmdfYXNwbmV0X212Y19zdG9yZS9kZWZhdWx0LmFzcHgfBmdkFCsAAhYKHwIFGTUuIEFkdmFuY2VkIEN1c3RvbWl6YXRpb24fAwUZNS4gQWR2YW5jZWQgQ3VzdG9taXphdGlvbh8EBSQvQWR2YW5jZWRfQ3VzdG9taXphdGlvbi9EZWZhdWx0LmFzcHgfBQUkL2FkdmFuY2VkX2N1c3RvbWl6YXRpb24vZGVmYXVsdC5hc3B4HwZnZBQrAAIWCh8CBRo2LiBTaWx2ZXJsaWdodCBhbmQgLk5FVCBDRh8DBRo2LiBTaWx2ZXJsaWdodCBhbmQgLk5FVCBDRh8EBREvU2lsdmVybGlnaHQuYXNweB8FBREvc2lsdmVybGlnaHQuYXNweB8GZ2QUKwACFgofAgUIQVBJIERvY3MfAwUIQVBJIERvY3MfBAUUL0FQSV9Eb2NzL0luZGV4LmFzcHgfBQUUL2FwaV9kb2NzL2luZGV4LmFzcHgfBmdkFCsAAhYMHwIFC0RldmVsb3BtZW50HwMFC0RldmVsb3BtZW50HwQFES9EZXZlbG9wbWVudC5hc3B4HwUFES9kZXZlbG9wbWVudC5hc3B4HwZnHwdnFCsABQUPMDowLDA6MSwwOjIsMDozFCsAAhYKHwIFGDEuIEJhc2ljcyBvZiBNVkMgYW5kIE1WUB8DBRgxLiBCYXNpY3Mgb2YgTVZDIGFuZCBNVlAfBAUjL0Jhc2ljc19vZl9NVkNfYW5kX01WUC9EZWZhdWx0LmFzcHgfBQUjL2Jhc2ljc19vZl9tdmNfYW5kX212cC9kZWZhdWx0LmFzcHgfBmdkFCsAAhYOHwIFJjIuIEltcGxlbWVudGluZyBjb3JlIE1WUCBmdW5jdGlvbmFsaXR5HwMFJjIuIEltcGxlbWVudGluZyBjb3JlIE1WUCBmdW5jdGlvbmFsaXR5HwQFMS9JbXBsZW1lbnRpbmdfY29yZV9NVlBfZnVuY3Rpb25hbGl0eS9EZWZhdWx0LmFzcHgfBQUxL2ltcGxlbWVudGluZ19jb3JlX212cF9mdW5jdGlvbmFsaXR5L2RlZmF1bHQuYXNweB8GZx4IU2VsZWN0ZWRnHwdnZBQrAAIWCh8CBSIzLiBEZXNpZ25pbmcgV2luZm9ybXMgdmlld3MgZW5naW5lHwMFIjMuIERlc2lnbmluZyBXaW5mb3JtcyB2aWV3cyBlbmdpbmUfBAUtL0Rlc2lnbmluZ19XaW5mb3Jtc192aWV3c19lbmdpbmUvRGVmYXVsdC5hc3B4HwUFLS9kZXNpZ25pbmdfd2luZm9ybXNfdmlld3NfZW5naW5lL2RlZmF1bHQuYXNweB8GZ2QUKwACFgofAgUeNC4gU3Ryb25nbHkgdHlwZWQgYXNzb2NpYXRpb25zHwMFHjQuIFN0cm9uZ2x5IHR5cGVkIGFzc29jaWF0aW9ucx8EBSkvU3Ryb25nbHktdHlwZWRfYXNzb2NpYXRpb25zL0RlZmF1bHQuYXNweB8FBSkvc3Ryb25nbHktdHlwZWRfYXNzb2NpYXRpb25zL2RlZmF1bHQuYXNweB8GZ2QUKwACFgofAgUHQ2hhbmdlcx8DBQdDaGFuZ2VzHwQFDS9DaGFuZ2VzLmFzcHgfBQUNL2NoYW5nZXMuYXNweB8GZ2QUKwACFgofAgUIRmVlZGJhY2sfAwUIRmVlZGJhY2sfBAUOL0ZlZWRiYWNrLmFzcHgfBQUOL2ZlZWRiYWNrLmFzcHgfBmdkFCsAAhYKHwIFCERvd25sb2FkHwMFCERvd25sb2FkHwQFDi9Eb3dubG9hZC5hc3B4HwUFDi9kb3dubG9hZC5hc3B4HwZnZGQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFgEFCmN0bDAwJE1lbnUvUzjBXtb1QaNpSPXSzRHQ+kIwSA==" />

        <div id="pageWrapper">
            
            <div>
                <img id="ctl00_logo" src="../Images/logo.PNG" border="0" />
                <div id="breadcrumbs">
                    <div><img id="ctl00_spacer" src="../Images/spacer.bmp" height="1" width="875" border="0" /></div>
                    <span id="ctl00_SiteMapPath"><a href="#ctl00_SiteMapPath_SkipLink"><img alt="Skip Navigation Links" height="0" width="0" src="../WebResourcee862.gif?d=-tf2UOPilGOzHQ2P_iOPlg2&amp;t=633440833918844552" border="0" /></a><span><a href="../Default.html">Home</a></span><span>&#160;&gt;&#160;</span><span><a href="../Documentation.html">Documentation</a></span><span>&#160;&gt;&#160;</span><span><a href="../Development.html">Development</a></span><span>&#160;&gt;&#160;</span><span>2. Implementing core MVP functionality</span><a id="ctl00_SiteMapPath_SkipLink"></a></span>
                </div>
            </div>
            <div id="menuAndContent">
                <div id="menu">
                    <a href="#ctl00_Menu_SkipLink"><img alt="Skip Navigation Links." src="../WebResourcee862.gif?d=-tf2UOPilGOzHQ2P_iOPlg2&amp;t=633440833918844552" width="0" height="0" border="0" /></a><table id="ctl00_Menu" cellpadding="0" cellspacing="0" border="0" width="238"><tr><td>
	<table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Documentation.html" id="ctl00_Menun0">Documentation</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Overview/Default.html" id="ctl00_Menun1">Overview</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Examples.html" id="ctl00_Menun2">Examples</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="http://mvcsharp.org/API_Docs/Index.aspx" id="ctl00_Menun9">API Docs</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Development.html" id="ctl00_Menun10">Development</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Basics_of_MVC_and_MVP/Default.html" id="ctl00_Menun11">1. Basics of MVC and MVP</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItemSelected menuItem"><a class="menuItemSelected menuItem" href="Default.html" id="ctl00_Menun12">2. Implementing core MVP functionality</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Designing_Winforms_views_engine/Default.html" id="ctl00_Menun13">3. Designing Winforms views engine</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td><table width="20">
				<tr>
					<td></td>
				</tr>
			</table></td><td class="menuItem"><a class="menuItem" href="../Strongly-typed_associations/Default.html" id="ctl00_Menun14">4. Strongly typed associations</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Changes.html" id="ctl00_Menun15">Changes</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Feedback.html" id="ctl00_Menun16">Feedback</a></td>
		</tr>
	</table><table cellpadding="0" cellspacing="0">
		<tr>
			<td class="menuItem"><a class="menuItem" href="../Download.html" id="ctl00_Menun17">Download</a></td>
		</tr>
	</table>
</td></tr></table><a id="ctl00_Menu_SkipLink"></a>
                </div> 
                <div id="content">  
                    
<h1>Part 2. Implementing core MVP functionality</h1>

<a href="#Introduction">Introduction</a><br/>
<a href="#Basic requirements">Basic requirements</a><br/>
<a href="#Designing key classes">Designing key classes</a><br/>
<a href="#Designing a simple views manager">Designing a simple views manager</a><br/>
<a href="#Summary">Summary</a><br/>

    <a id="Introduction"></a><h2>Introduction</h2>
    <p>
        In the <a href="../Basics_of_MVC_and_MVP/Default.html">previous article</a> we have made our choice in favour of the Model-View-Presenter
        architectural pattern. Thus our final goal is the creation of the MVP framework.
        However we should firstly make it clear what does mean “MVP framework” by deciding
        what the future system will be intended for and what problems it will solve.</p>
    <p>
        In this article we will start with clarifying the aim of our system and gathering
        some basic requirements for it. After that we will proceed to the design and implementation
        stages creating fundamental classes that will meet our basic requirements.</p>
    <a id="Basic requirements"></a><h2>
        Basic requirements</h2>
    <p>
        The aim of our system can be formulated as follows: it should simplify the usage
        of the MVP pattern by developers. The system should make it easier to fulfill every
        common task within the MVP approach. For example it should simplify such actions
        as navigating between views, accessing controllers, etc. For each common operation
        we will analyze how our system can help in performing it and by doing so we will
        construct requirements to the system. We will express the requirements in a popular
        form of use cases, each describing the desired interactions between a user and the
        system.</p>
    <h3>
        Starting a task</h3>
    <p>
        To begin with let us consider how a user would start a task. Starting a task implies
        certain processing (registering and initializing the task) so it would be nice to
        delegate this work to the system (MVP framework). A user should be able to specify
        actions performed on a task start by implementing some OnStart method. Thus given
        a task descriptor the system should perform necessary processing and call the task
        OnStart handler.</p>
    
<pre><span style="text-decoration: underline">Starting a task</span>
    User: Pass the task descriptor to the system and ask to start the task.
    System: Register the task, initialize it and invoke OnStart handler.</pre>

<p>
    Here a task descriptor is something that describes the task, specifically its structure
    and its properties. Let us decide what will be convenient to use as a task descriptor.</p><p>
        Since every task is a part of an application we might want to describe tasks directly
        in the source code of the application. A good way of defining an entity (such as
        task) in a source code is using a type definition construct. Therefore a task type
        can be used as its descriptor. Moreover a task type (class) may define OnStart handler
        method and an instance of this type can hold the task state at runtime. So this
        is how the revised version of the “Starting a task” use case looks:</p>
    <pre><span style="text-decoration: underline">Starting a task (revision 1)</span>
    User: Pass the task type to the system and ask to start the task.
    System: Create a task instance, register and initialize it and invoke its
            OnStart operation.</pre>
    <p>
        Of course there must be some framework class which processes start task requests
        from a user. Let us call it TasksManager:</p>
    <p><img src="Images/1.png"/></p>
    <h3>
        Navigating from within a task</h3>
    <p>
        Every task involves a number of views with transitions possible between them. At
        this point let us discuss how a user would navigate to some view from a task code.
        Say some view should be activated in the OnStart handler code. It would be convenient
        if the navigation is done by the framework and the navigation logic is isolated
        in some Navigator class. Then each user task instance should be associated with
        a proper navigator instance.</p>
    <p><img src="Images/2.png"/>&nbsp;</p>
    <pre><span style="text-decoration: underline">Navigating from within a task</span>
    Precondition: The task is associated with a proper navigator instance.
    User: Ask that associated navigator to navigate to some view.
    System: Do the navigation, alter the task state.</pre>

    <p>
        It is important to note that the precondition requires each task to be linked to
        its navigator. Such linking may be done during the task start process. So here is
        the modified version of “Starting a task” use case:</p>
    
    <pre><span style="text-decoration: underline">Starting a task (revision 2)</span>
    User: Pass the task type to the system and ask to start the task.
    System: Create a task and a navigator instances, initialize and link them
            together. Invoke the OnStart operation on the task instance.</pre>
    <h3>
        Using various presentation mechanisms</h3>
    <p>
        According to the MVP paradigm the system should make it easy to use different presentation
        mechanisms for example Web or Windows UI. A presentation mechanism has influence
        upon how switching between views is done. Therefore it seems quite reasonable to
        encapsulate view-switching code in a separate ViewsManager abstract class with subclasses
        for each specific UI kind. Then the Navigator class containing some common navigation
        logic will be associated with the ViewsManager class.</p>
    <p>
        We can not yet formulate any use case for this requirement however the arguments
        above prove the need of the ViewsManager concept. Thus the domain model at the moment
        looks as follows:</p>
    <p><img src="Images/3.png"/></p>
    <h3>
        Describing a task structure</h3>
    <p>
        From the previous article we know that every task consists of a number of interaction
        points. Each interaction point in its turn is characterized by its view, controller
        and possible transitions to the other interaction points (in the previous article
        we decided to use "Controller" notation instead of "Presenter" so do not get confused
        with such naming). A picture illustrating
        this is below:</p>
    <p><img src="Images/4.png"/>&nbsp;</p>
    <p>
        For each linked pair of source and target interaction points the NavigationTrigger
        instance defines a trigger which should be called to perform the navigation. For
        example a trigger “Next” may cause a transition from “Step1” view to “Step2” view
        in a wizard-like application.</p>
    <p>
        Notice that we don’t specify any view type in the InteractionPointInfo class since
        specific view implementations are the prerogative of view managers.</p>
    <p>
        As we have decided to describe a task by its type let us find out how we can accompany
        a type definition in .NET with a task structural information. Interaction points
        can be declared in a form of constant fields inside the task type. This allows referencing
        interaction points in a compiler-checked way rather than using literal strings.
        For example one may call Navigate(MyTask.View1) instead of Navigate("View 1").</p>
    <pre><span style="color: #0000FF;">class</span><span style="color: #000000;"> WashDishesTask
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Below are three interaction point definitions
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> with the view names specified</span><span style="color: #008000;">
</span><span style="color: #000000;">    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> SelectDishes </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Select dishes view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> Dishwasher </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Dishwasher view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> WashComplete </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Wash complete view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;    
}</span></pre>

    <p>
        Such constant field alone describes an interaction point party, specifying
        only the view name. We need a means to accompany such fields with controller type
        and navigation triggers declarations. A good way to equip language elements (fields,
        in particular) in .NET with some additional info is using .NET custom attributes. In our
        case it might look as follows:</p>
    <pre><span style="color: #0000FF;">class</span><span style="color: #000000;"> WashDishesTask
{
    [InteractionPoint(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(SelectDishesController))]
    [NavTarget(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Next</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">, Dishwasher)]
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> SelectDishes </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Select dishes view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;

    [InteractionPoint(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(DishwasherController))]
    [NavTarget(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Next</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">, WashComplete)]
    [NavTarget(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Previous</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">, SelectDishes)]
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> Dishwasher </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Dishwasher view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;

    [InteractionPoint(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(WashCompleteController))]
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> WashComplete </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800000;">&quot;</span><span style="color: #800000;">Wash complete view</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;    
}</span></pre>

    <p>
        The suggested here approach for describing tasks seems to be more or less handy to start with. With it the revised version of the "Starting a task" use case looks
        so:</p>
    <pre><span style="text-decoration: underline">Starting a task (revision 3)</span>
    User: Add fields describing interaction points to the task type. Equip these
          fields with [InteractionPoint] and [NavTarget] attributes. Then pass
          the task type to the system and ask to start the task.
    System: Extract the task information from its type. Create a task and a
            navigator instances, initialize and link them together. Invoke the
            OnStart operation on the task instance.</pre>
    <h3>
        Accessing the controller from a view and vice versa</h3>
    <p>
        According to the MVP pattern views handle user gestures and then pass control to
        the corresponding controller (and again I recall that we are using the "controller"
        name instead of "presenter"). Moreover in MVP (in contrast to MVC) controllers may
        access their views as well. Hence it should be easy for a user to access the controller
        from a view code and vice versa. In MVP this is solved by linking together each
        view with the corresponding controller instance.</p>
    <pre><span style="text-decoration: underline">Accessing the controller from a view and vice versa</span>
    Precondition: View and its controller are linked to each other.
    User: Access that associated controller/view. </pre>
    <p><img src="Images/41.png"/></p>
    <p>
        For user’s convenience it should be the framework job to link views and controllers
        together. Later when designing classes we will discuss which class will be responsible
        for such linking.</p>
    <h3>
        Accessing the task and navigating from a controller</h3>
    <p>
        Controllers often need to request/modify their task state. So we may require each
        controller to be linked to its task.</p>
    <pre><span style="text-decoration: underline">Accessing the task from a controller</span>
    Precondition: Controller is linked to its task.
    User: Access that associated task.</pre>
    <p><img src="Images/5.png">&nbsp;</p>
    <p>
        A controller may also need to trigger navigation to some view. This is done easily
        by accessing the task and then getting its navigator.</p>
    <pre><span style="text-decoration: underline">Navigating from within a controller</span>
    Precondition: Controller is linked to its task which is connected to the
                  navigator
    User: Access the navigator through the associated task. Invoke the navigation.</pre>
    <p>
        We have discussed the most fundamental requirements for the future system. Based
        on these requirements we are going to proceed to designing classes.</p>
    <a id="Designing key classes"></a><h2>
        Designing key classes</h2>
    <p>
        Above we have introduced a number of fundamental concepts such as task, navigator
        and others by analyzing requirements for our system. These concepts with the relationships
        between them make up so called analysis model of the system. Analysis classes from
        this model usually turn into design classes by being equipped with operations, additional
        attributes and other details.</p>
    <p>
        Here we are going to walk through all the requirements we have formulated and to
        design classes based on the analysis model in order to meet these requirements.</p>
    <h3>
        TasksManager</h3>
    <p>
        First let us deal with the “Starting a task (revision 3)” use case and the TasksManager
        concept. According to this use case we may introduce a TasksManager class with a
        StartTask(taskType: Type) method. This method should create task and navigator instances,
        connect them to each other and invoke the task’s OnStart() method. It should also
        create a TaskInfo instance based on the task type. Tasks are designed by users however
        in order for the framework to communicate with task instances the latter should
        conform to some interface. Let us call it ITask. There is also a requirement we
        have missed: tasks should be able to access their tasks manager, that is why the
        TasksManager should also link the created task to itself.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TasksManager
{
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ITask StartTask(Type taskType)
    {
        TaskInfo ti </span><span style="color: #000000;">=</span><span style="color: #000000;"> GetTaskInfo(taskType); </span><span style="color: #008000;">//</span><span style="color: #008000;"> get TaskInfo from task type</span><span style="color: #008000;">
</span><span style="color: #000000;">        Navigator n </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> Navigator(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> create navigator</span><span style="color: #008000;">
</span><span style="color: #000000;">        ITask t </span><span style="color: #000000;">=</span><span style="color: #000000;"> CreateHelper.Create(taskType) </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> ITask; </span><span style="color: #008000;">//</span><span style="color: #008000;"> create task</span><span style="color: #008000;">
</span><span style="color: #000000;">
        t.TasksManager </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">this</span><span style="color: #000000;">; </span><span style="color: #008000;">//</span><span style="color: #008000;"> link the created task to itself</span><span style="color: #008000;">
</span><span style="color: #000000;">        n.Task </span><span style="color: #000000;">=</span><span style="color: #000000;"> t; </span><span style="color: #008000;">//</span><span style="color: #008000;"> connect the navigator to the task</span><span style="color: #008000;">
</span><span style="color: #000000;">        t.Navigator </span><span style="color: #000000;">=</span><span style="color: #000000;"> n; </span><span style="color: #008000;">//</span><span style="color: #008000;"> and the task to the navigator</span><span style="color: #008000;">
</span><span style="color: #000000;">        t.OnStart(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> invoke the task's OnStart()</span><span style="color: #008000;">
</span><span style="color: #000000;">        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> t;
    }
}</span></pre>
    <p>
        GetTaskInfo - is a method that extracts task information from a task type. Above
        we suggested to describe tasks by inserting constant fields to the type definition.
        However there may be other ways to equip a task type with the task information.
        Hence different methods to extract such information may exist. We will isolate the
        extraction logic in a ITaskInfoProvider interface with a GetTaskInfo(taskType: Type):
        TaskInfo method.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">interface</span><span style="color: #000000;"> ITaskInfoProvider
{
    TaskInfo GetTaskInfo(Type taskType);
}</span></pre>
    <p>
    </p>
    <p>
        It is worth keeping all configuration data including task and view descriptions
        in a centralized MVCConfiguration class. Then each tasks manager will be linked
        to its own MVCConfiguration instance:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TasksManager
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> MVCConfiguration Config</span></pre>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> MVCConfiguration
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ITaskInfoProvider TaskInfoProvider</span></pre>
    <p>
    </p>
    <p>
        A user may start a task of the same type more then once; and extracting the task
        information each time is redundant. That is why we need a repository object for
        all tasks configuration data. Let it be TaskInfoCollection instance.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> MVCConfiguration
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> TaskInfoCollection TaskInfos</span></pre>
    <p>
        If the necessary task info object already exists in the inner hash table the TaskInfoCollection
        will return it, otherwise it will extract a new TaskInfo object from the task type
        with the help of the TaskInfoProvider class:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TaskInfoCollection
{
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> Hashtable taskInfos </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> Hashtable();
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> MVCConfiguration mvcConfig;

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> TaskInfo </span><span style="color: #0000FF;">this</span><span style="color: #000000;">[Type taskType]
    {
        </span><span style="color: #0000FF;">get</span><span style="color: #000000;">
        {
            TaskInfo ti </span><span style="color: #000000;">=</span><span style="color: #000000;"> taskInfos[taskType] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> TaskInfo;
            </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (ti </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">)
            {
                ti </span><span style="color: #000000;">=</span><span style="color: #000000;"> mvcConfig.TaskInfoProvider.GetTaskInfo(taskType);
                taskInfos[taskType] </span><span style="color: #000000;">=</span><span style="color: #000000;"> ti;
            }
            </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> ti;
        }
        </span><span style="color: #0000FF;">set</span><span style="color: #000000;"> { taskInfos[taskType] </span><span style="color: #000000;">=</span><span style="color: #000000;"> value; }
    }
}</span></pre>
    <p>
        Finally this is how the TasksManager.GetTaskInfo(...) method looks:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TasksManager
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> TaskInfo GetTaskInfo(Type taskType)
    {
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> Config.TaskInfos[taskType];
    }</span></pre>
    <h3>
        Navigator</h3>
    <p>
        Now let us look into how the navigation occurs. Navigator class should have a public
        Navigate(..) method with a navigation trigger name passed as parameter.</p>
    <p>
        For a navigator to switch to another view it needs to know the task navigation structure.
        Therefore it should be linked to the TaskInfo instance describing that task. Such
        linking can be done in the TasksManager.StartTask(...) method:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TasksManager
...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ITask StartTask(Type taskType)
    {
        ...
        n.TaskInfo </span><span style="color: #000000;">=</span><span style="color: #000000;"> ti;
        ...
    }</span></pre>
    <p>
        Task information is not the only needed component for a navigator to do the navigation.
        Another important thing we have introduced in the analysis phase is the views manager
        concept. Its responsibility is actual view switching, with different views manager
        implementations capable of different presentation mechansims. The navigator will
        be connected to the views manager in the TasksManager.StartTask(...) method:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TasksManager
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ITask StartTask(Type taskType)
    {
        ...
        IViewsManager vm </span><span style="color: #000000;">=</span><span style="color: #000000;"> CreateHelper.Create(Config.ViewsManagerType)
                           </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IViewsManager;
        n.ViewsManager </span><span style="color: #000000;">=</span><span style="color: #000000;"> vm;
        vm.Navigator </span><span style="color: #000000;">=</span><span style="color: #000000;"> n;
        ...
    }</span></pre>
    <p>
        Note that we are using the MVCConfiguration class to store the used views manager
        type.</p>
    <p>
        Now we are ready to write code for the Navigator.Navigate(...) operation:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Navigator
{
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> TaskInfo TaskInfo
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> IViewsManager ViewsManager
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> Navigate(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> triggerName)
    {
        </span><span style="color: #0000FF;">string</span><span style="color: #000000;"> nextViewName </span><span style="color: #000000;">=</span><span style="color: #000000;"> TaskInfo.GetNextViewName(Task.CurrViewName,
                                                       triggerName);
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (nextViewName </span><span style="color: #000000;">==</span><span style="color: #000000;"> Task.CurrViewName) </span><span style="color: #0000FF;">return</span><span style="color: #000000;">;
        NavigateDirectly(nextViewName);
    }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> NavigateDirectly(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        Task.CurrViewName </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewName;
        ViewsManager.ActivateView(Task.CurrViewName);
    }
}</span></pre>
    <a id="Designing a simple views manager"></a><h2>
        Designing a simple views manager</h2>
    <p>
        Up to the moment we have roughly designed all key classes except for a views manager
        class. Let us build a simple IViewsManager implementation. Although simple, it will
        be a basis for more complicated real-life views managers.</p>
    <p>
        To make our views manager as simple as possible let us assume that views are usual
        windows forms. Then our SimpleFormsViewsManager will be responsible for switching
        between those forms.</p>
    <p><img src="Images/6.png">&nbsp;</p>
    <h3>
        ViewInfo</h3>
    <p>
        In order to activate a form for the first time it needs to be created. Therefore
        the views manager should know the view type by its name. We will encapsulate the
        information about a view type in a ViewInfo class instance. Thus, given a view name,
        the view manager should retrieve the corresponding ViewInfo object through the intermediate
        ViewInfoCollection object.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> ViewInfoCollection
    ...    
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ViewInfo </span><span style="color: #0000FF;">this</span><span style="color: #000000;">[</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName]
    {
        </span><span style="color: #0000FF;">get</span><span style="color: #000000;"> { </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> viewInfoCollection[viewName] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> ViewInfo; }
        </span><span style="color: #0000FF;">set</span><span style="color: #000000;"> { viewInfoCollection[viewName] </span><span style="color: #000000;">=</span><span style="color: #000000;"> value; }
    }</span></pre>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> ViewInfo
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> Type ViewType</span></pre>
    <p>
        Subsequent (second, third, etc.) view activations don’t require the view creation.
        Instead they require locating the already created view by its name. For this the
        views manager should have an association to a FormCollection class returning already
        created views by their names.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> SimpleFormsViewsManager : IViewsManager
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> Dictionary</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">, Form</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> forms
            </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> Dictionary</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">, Form</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">();</span></pre>
    <p>
        The question is where a views manager takes the view descriptions (ViewInfo objects)
        from. As views are parts of a task it is natural to store their descriptions within
        that task’s description:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> TaskInfo
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ViewInfoCollection ViewInfos</span></pre>
    <p>
        This approach does not bind tasks to any specific presentation mechanism since the
        base ViewInfo class is independent of a specific presentation.</p>
    <p>
        Next question is how a ViewInfoCollection gets populated. Obviously a user can modify
        the collection at runtime. However usually a task structure is known at design time,
        and a declarative syntax to describe it may apply. A good solution is to mark view
        types with a [View] attribute like this:</p>
    <pre lang=cs><span style="color: #000000;">[View(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(Task1), “View1”)]
</span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Form1: Form
…</span></pre>
    <p>
        Here we declare that the TaskInfo object for Task1 should contain a ViewInfo instance
        pointing to the Form1 type. Of course there should be a class which will generate
        ViewInfo objects from such declarations. Let us assign this responsibility to a
        IViewInfosProvider interface with a GetFromAssembly(assembly:Assembly) operation.
        It will generate ViewInfo objects from the declarations in the input assembly:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">interface</span><span style="color: #000000;"> IViewInfosProvider
{
    ViewInfosByTaskCollection GetFromAssembly(Assembly assembly);
}</span></pre>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> DefaultViewInfosProvider : IViewInfosProvider
...</span></pre>
    <h3>
        ActivateView implementation</h3>
    <p>
        In general the view activation mechanism is quite simple: the necessary form should
        be found by its name and then the Form.Show() and Form.Activate() methods should
        be called on it.</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> SimpleFormsViewsManager : IViewsManager
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> ActivateView(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        Form f </span><span style="color: #000000;">=</span><span style="color: #000000;"> FindOrCreateView(viewName);
        f.Show();
        f.Activate();
    }</span></pre>
    <p>
        The FindOrCreate operation above should create the view in case it does not exist
        yet. Of course a view creation implies certain initialization steps. These steps
        may be derived from the requirements to our system. Take a look at the “Accessing
        the controller from a view and vice versa” use case. It requires a view to be linked
        to the controller during the initialization process:</p>
    <pre lang=cs><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> SimpleFormsViewsManager : IViewsManager
    ...
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> Form FindOrCreateView(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        Form result;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (</span><span style="color: #000000;">!</span><span style="color: #000000;">forms.TryGetValue(viewName, </span><span style="color: #0000FF;">out</span><span style="color: #000000;"> result))
        {
            result </span><span style="color: #000000;">=</span><span style="color: #000000;"> CreateHelper.Create(ViewInfos[viewName].ViewType) </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> Form;
            forms[viewName] </span><span style="color: #000000;">=</span><span style="color: #000000;"> result;
            (result </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView).ViewName </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewName;
            InitializeView(result </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView);
        }
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> result;
    }

    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> InitializeView(IView view)
    {
        view.Controller </span><span style="color: #000000;">=</span><span style="color: #000000;"> Navigator.GetController(view.ViewName);
        view.Controller.View </span><span style="color: #000000;">=</span><span style="color: #000000;"> view;
    }</span></pre>
    <p>
        In this code we make the Navigator class responsible for holding the controllers
        for its task. Navigator will also create and initialize controllers if needed. According
        to the “Accessing the task and navigating from a controller” use case a controller
        initialization should include its linking to the task:</p>
    <pre lang=cs><div><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Navigator
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> IController GetController(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        IController result </span><span style="color: #000000;">=</span><span style="color: #000000;"> controllers[viewName] </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IController;
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (result </span><span style="color: #000000;">==</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">)
        {
            InteractionPointInfo iPointInf </span><span style="color: #000000;">=</span><span style="color: #000000;"> TaskInfo.InteractionPoints[viewName];
            result </span><span style="color: #000000;">=</span><span style="color: #000000;"> CreateHelper.Create(iPointInf.ControllerType) </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IController;
            result.Task </span><span style="color: #000000;">=</span><span style="color: #000000;"> Task;
            controllers[viewName] </span><span style="color: #000000;">=</span><span style="color: #000000;"> result;
        }
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> result;
    }</span></pre>
    <h3>
        Manual view activation</h3>
    <p>
        What happens when a user himself clicks on a form and activates it? That means the
        user decides to do the navigation to the selected view. Thus the Navigator.Navigate(…)
        operation should be called in response to the manual view activation. We can implement
        this by handling the Form.Activated event:</p>
    <pre lang=cs><div><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> SimpleFormsViewsManager : IViewsManager
    ...
    </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> view_Activated(</span><span style="color: #0000FF;">object</span><span style="color: #000000;"> sender, EventArgs e)
    {
        Navigator.TryNavigateToView((sender </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> IView).ViewName);
    }</span></pre>
    <pre lang=cs><div><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Navigator
    ...
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> TryNavigateToView(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> viewName)
    {
        </span><span style="color: #0000FF;">if</span><span style="color: #000000;"> (TaskInfo.CanNavigateToView(Task.CurrViewName, viewName))
            Task.CurrViewName </span><span style="color: #000000;">=</span><span style="color: #000000;"> viewName;
        ViewsManager.ActivateView(Task.CurrViewName);
    }</span></pre>
    <p>
        Navigator.TryNavigateToView(...) does the following: if navigation to the destination
        view is possible via any of the navigation tree ribs (i.e. CanNavigateToView returns
        true) then the destination view gets activated, otherwise the source view is activated.
        Thus if a user clicks on a view that is not accessible from the current one, then
        the task will remain in the current view and the views manager will switch back
        to the current view.</p>
    <a id="Summary"></a><h2>
        Summary</h2>
    <p>
        Throughout this article we have developed the core classes of the future MVP framework.
        These classes help users in fulfilling the main Model-View-Presenter usage scenarios,
        and establish a firm ground for the futher famework's growth and extension.</p>
    <p>
        <em>
        Note that the SimpleFormsViewsManager class sources as well as examples on using
        MVC# framework are bundled with MVC# sources and located in the "Examples" folder.</em></p>
    <p>
        <a href="../Designing_Winforms_views_engine/Default.html">Proceed to Part 3: Designing a
        Windows Forms views engine</a></p>        

                </div>
            </div>
        </div>
        <div style="text-align:center; font-size:11px;">Copyright © www.MVCSharp.org</div>
    </form>
</body>

<!-- Mirrored from mvcsharp.org/Implementing_core_MVP_functionality/Default.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 30 Oct 2008 03:47:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>
